```
🔎 Note

6장에서 보았듯이, 데이터 타입은 크게
원시 타입(primitive type)과 객체 타입(object/reference type)으로 구분지어진다.

그러나 데이터 타입을 원시 타입과 객체 타입으로 구분하는 이유는 무엇일까??

이는 크게 세가지 측면에서 원시 타입과 객체 타입이 다르기 때문이다.

1️⃣ 원시 타입의 값, 즉 원시 값은 변경 불가능한 값이기 때문이며,
   이에 비해 객체 타입의 값, 즉 객체는 변경 가능한 값이다.

2️⃣ 원시 값을 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값이 저장된다.
   그러나 객체를 변수에 할당하면 변수(확보된 메모리 공간)에는 참조 값이 저장된다.

3️⃣ 값에 의한 전달(passy by value)인 원시 값이 복사되어 전달되는 방식,
   참조에 의한 전달(pass by reference)인 참조 값이 복사되어 전달되는 방식으로 나뉘기 때문이다.

그러면 이러한 차이점을 기반으로 원시 값과 객체를 비교해보자!
```
<br>

# 원시 값

> 💡 원시 타입의 값, 즉 원시 값은 `3가지 특징`을 가진다.
<br>

## 1️⃣ 변경 불가능한 값

> 💡 `원시 값은 변경 불가능한 값`이며, `한 번 생성된 원시 값은 읽기 전용(read only) 값`으로서 변경할 수 없다.
>> `변경 불가능하다는 것은 변수가 아니라 값에 대한 진술`이다.

>> 변수는 메모리 공간을 식별하기 위해 붙인 이름이므로, `메모리 그 자체에 저장된 데이터값인 값`을 보아야한다.
<br>

```js
🔎 Note

그러면 변수와 상대되는 개념인 상수, 즉 재할당이 금지된 변수인 상수는 변수와 같이 변경(교체)할 수 있을까?

"변수"
- 언제든지 재할당을 통해 변수 값을 변경(교체)할 수 있다.

"상수"
- "상수"는 재할당이 금지된 변수이며, 값을 저장하기 위한 메모리 공간이 필요하므로 변수이다.
- 그러나, "상수"는 단 한 번만 할당이 허용되므로 변수 값을 변경(교체)할 수 없다.
```
<br>

## 2️⃣ 불변성

> 💡 `불변성(immutability)`이란, 변경 불가능한 원시 값의 특성을 뜻한다.
>> `새로운 메모리 공간을 확보하고 재할당한 값을 저장`한 후, `변수가 참조하던 메모리 공간의 주소를 변경`한다.
<br>

- 불변성을 갖는 원시 값을 할당한 변수는 **재할당 이외에 변수 값을 변경할 수 있는 방법이 없다.**
  - 이는 값의 변경, 즉 상태 변경을 추적 가능하게 한다.

<br>

```js

var num = 1;
num = 2;

console.log(num); // 2
// 변수 num 이 참조했던 원시 값 1의 메모리 공간 주소는 그대로 남아있다.
// 이는 변수에 할당된 원시 값이 변경 불가능한 값이기 때문이며,
// 재할당하여 메모리 공간의 주소를 변경한 것이기 때문이다.


var str = 'string';
str[0] = 'S';

console.log(str); // string
// str[0] = 'S' 처럼 이미 생성된 문자열의 일부 문자를 변경해도 반영되지 않는다.
// 원시 값인 문자열은 변경 불가능한 값이기 때문이다.

```

<br>

```js

🔎 Note

"유사 배열 객체(array-like object)"

- 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고, length 프로퍼티를 갖는 객체이다.
- length 프로퍼티를 갖기 때문에 "유사 배열 객체"이며, for 문으로 순회할 수도 있다.


var str = 'string';

// 문자열은 유사 배열이므로 배열과 유사하게 인덱스를 사용해 각 문자에 접근할 수 있다.
console.log(str[0]); // s

// 원시 값인 문자열이 객체처럼 동작한다.
console.log(str.length); // 6
console.log(str.toUpperCase()); // STRING

```
<br>

## 3️⃣ 값에 의한 전달

> 💡 값에 의한 전달(passy by value)
>> `변수에 원시 값을 갖는 변수를 할당`하면 `할당받는 변수에는 할당되는 변수의 원시 값이 복사되어 전달`된다.
<br>

```js

var score = 80;
// copy 변수에는 score 변수의 값 80이 복사되어 할당된다.
var copy = score;

console.log(score); // 80
console.log(copy);  // 80

console.log(score, copy); // 80 80
console.log(score === copy); // true


score = 100;

console.log(score); // 100
console.log(copy);  // 80

console.log(score, copy); // 100 80
console.log(score === copy); // false

```
<br>

- 변수 score의 값을 재할당해도, 변수 copy의 값은 80이 할당되어 있다.
  - **왜 변수 score에는 원시 값 100이 아닌 80이 할당되어 있을까??**

```js
🔎 Note

[값에 의한 전달은 변수에 값을 전달할까?]

엄격하게 포현하면 "변수"에는 값이 전달되는 것이 아니라 "메모리 주소가 전달"된다.
변수와 같은 "식별자는 값이 아니라 메모리 주소를 기억"하고 있기 때문이다.

따라서 '값에 의한 전달'은 값을 전달하는 것이 아닌 메모리 주소를 전달하며,
참조한 변수 즉, 원본 메모리 공간의 값과는 다른 메모리 공간에 저장된다.


결국 두 변수의 원시 값은 "서로 다른 메모리 공간에 저장된 별개의 값"이 되어
"한쪽에서 재할당을 통해 값을 변경"하더라도 "서로 간섭할 수 없는 것"이다.
```
<br>

# 객체

> 💡 객체는 원시 값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없다.
>> `프로퍼티의 개수가 정해져 있지 않으며`, `동적으로 추가되고 삭제할 수 있고`, `프로퍼티 값에 제약이 없기 때문`이다.

<br>

## 1️⃣ 변경 가능한 값

> 💡 객체(참조) 타입의 값, 즉 `객체는 변경 가능한 값(mutable value)`이다.
>> 객체를 할당한 변수는 `재할당 없이 객체를 직접 변경`할 수 있다.
<br>

- **원시 값을 할당한 변수는 원시 값 자체를 갖는다.**
  - 원시 값을 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근할 때

- **객체를 할당한 변수**가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 **참조 값(reference value)에 접근** 할 수 있다.
  - **참조 값**은 생성된 객체가 저장된 메모리 공간의 주소, 그 자체이다.
<br>

```js

var person = {
   name : 'Lee'
};

// 프로퍼티 값 갱신
person.name = 'Kim';

// 프로퍼티 동적 생성
person.address = 'Seoul';

console.log(person); // {name: "Kim", address: "Seoul"}

```
<br>

```js
🔎 Note

[왜 객체는 원시 값과 달리 변경 가능한 값일까?]

객체를 변경할 때 마다 원시 값처럼 이전 값을 복사해서 새롭게 생성한다면
명확하고 신뢰성이 확보되겠지만 "이에 따른 단점도 존재"한다.

1️⃣ 크키가 매우 클 수 있으며,
2️⃣ 원시 값처럼 크기가 일정하지도 않으며,
3️⃣ 프로퍼티 값이 객체일 수도 있어서 복사해서 생성하는 비용이 많이 든다.

⇒ 이는 "메모리의 효율적 소비가 어렵고 성능이 나빠진다."


따라서 "메모리를 효율적으로 사용하기 위해" 객체는 "변경 가능한 값으로 설계"한 것이다.

그러나 이 때문에 "여러 개의 식별자가 하나의 객체를 공유할 수 있다"는 단점 또한 존재한다.
```
<br>

## 2️⃣ 참조에 의한 전달

> 💡 `참조에 의한 전달(pass by reference)`은 `객체를 가리키는 변수를 다른 변수에 할당`시, `원본의 참조 값이 복사되어 전달`되는 것이다.
>> 이는 여러 개의 식별자가 하나의 객체를 가리킬 수 있으며 객체의 단점으로 꼽힌다.

>> 하나의 객체를 공유할 때 어떤 부작용이 발생하는가?
<br>

### 얕은 복사와 깊은 복사



