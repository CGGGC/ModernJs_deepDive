```js

🔎 Note

[들어가기에 앞서]

"전역 변수의 무분별한 사용은 위험"하다.
전역 변수를 반드시 사용해야 할 이유를 찾지 못한다면 "지역 변수를 사용"하도록 하자.

그렇다면, "어떤 이유에서 전역 변수의 사용이 지양"되는 것인가?
```
<br>

# 변수의 생명 주기

> 💡 `변수의 생명 주기` : 메모리 공간이 확보(allocate)된 시점부터
메모리 공간이 해제(release)되어 가용 메모리 풀(memory pool)에 반환되는 시점까지 이다.
>> 변수에 이 생명주기가 없다면, 한번 선언된 변수는 프로그램이 종료되기 전 까지 메모리 공간을 점유하게 된다.
<br>

## 1️⃣ 지역 변수의 생명 주기

> `지역 변수의 생명 주기는 함수의 생명 주기와 일치`한다.
<br>

```js

function foo() {
  var x = 'local';
  console.log(x); // local
  return x;
}

foo();
console.log(x); // ReferenceError: x is not defined

// 1. foo 함수 호출
// 2. 다른 문들이 실행되기 이전에 x 변수의 선언문이 JS 엔진에 의해 가장 먼저 실행
// 3. x 변수가 선언되고 undefined로 초기화
// 4. 그 후, 변수 할당문이 실행되면 x 변수에 값이 할당
// 5. 함수가 종료된 뒤 x 변수도 소멸되어 생명 주기가 종료

```

- 변수 선언은 런타임 이전 단계에서 자바 스크립트 엔진에 의해 먼저 실행된다.
  - 다만, 엄밀히 말하자면 **변수 선언은 전역 변수에 한정된 것**이다.
<br>

## 2️⃣ 전역 변수의 생명 주기

> var 키워드로 선언한 `전역 변수의 생명 주기는 전역 객체의 생명 주기와 일치`한다.
<br>

```js

🔎 Note

[전역 객체(global object)]

"전역 객체" : 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 "어떤 객체보다도 먼저 생성"되는 특수한 객체.

브라우저 ⇒ window, Node.js ⇒ global 객체를 의미
그러나 ES11에서 전역 객체를 가리키는 다양한 식별자들이 "globalThis로 통일" 되었다.

"표준 빌트인 객체"(Object, String, Number, Function, Array...) &
"환경에 따른 호스트 객체"(클라이언트 Web API 또는 Node.js의 호스트 API) &
"var 키워드로 선언한 전역 변수와 전역 함수 프로퍼티"를 가진다
```
<br>

- 전역 코드는 명시적인 호출 없이 실행된다.
  - 함수와 달리 전역 코드는 반환문을 사용할 수 없으므로 `마지막 문이 실행되어 더 이상 실행할 문이 없을 때 종료`한다.
<br>

# 전역 변수의 문제점

> 1️⃣ `암묵적 결합(implicite coupling)` : 모든 코드가 전역 변수를 참조하고 변경을 허용
>> 이는 변수의 유효범위가 크면 클수록 가독성이 저하되며, 값이 변경될 수 있는 위험성 또한 증가한다.
<br>

> 2️⃣ `긴 생명 주기`
>> 이는 메모리 리소스를 오랜 기간 소비하며,
생명 주기가 월등히 길기 때문에 변수 이름이 중복될 가능성이 높다.
<br>

> 3️⃣ `스코프 체인 상에서 종점에 존재`
>> 변수를 검색할 때 전역 변수는 가장 마지막에 검색되므로, 검색 속도가 가장 느리다.
<br>

> 4️⃣ `네임스페이스 오염`
>> 자바스크립트는 파일이 분리되어있어도 하나의 전역 스코프를 공유한다.
때문에, 동일한 변수명이 존재한다면 예상치 못한 결과를 초래할 수 있다.
<br>

# 전역 변수의 사용을 억제하는 방법
<br>

## 1️⃣ 즉시 실행 함수

>  `즉시 실행 함수` : 함수 정의와 동시에 호출되는 함수
<br>

```js

(function () {
  var foo = 10;  // 즉시 실행 함수의 지역 변수
  // ...
}());

console.log(foo);  // ReferenceError: foo is not defined

```

- 모든 코드를 **즉시 실행 함수로 감싸면, 모든 변수는 즉시 실행 함수의 지역 변수**가 된다.
<br>

## 2️⃣ 네임스페이스 객체

>  `전역에 네임스페이스(namespace) 역할을 담당할 객체를 생성`하고,
`전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가`하는 방법이다.
<br>

```js

var MYAPP = {}; // 전역 네임스페이스 객체

MYAPP.name = 'Lee'; // 프로퍼티로 추가

// 또 다른 네임스페이스 객체를 프로퍼티로 추가할 수 있다.
MYAPP.person = {
  address: 'Seoul'
};

console.log(MYAPP.name); //  Lee
console.log(MYAPP.person.address); // Seoul

```

- 네임스페이스를 분리해 식별자 충돌을 방지하는 효과가 있다.
  - 그러나, **네임스페이스 객체 자체가 전역 변수에 할당**되므로 그다지 유용하지 않다.
<br>

## 3️⃣ 모듈 패턴

>  클래스를 모방 & 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 `하나의 모듈을 만듦.`
>> 모듈 패턴의 특징 : `전역 변수의 억제는 물론 캡슐화까지 구현 가능`
<br>

```js
🔎 Note

[모듈 패턴에서의 캡슐화(encapsulation)란?]

캡슐화 : "객체의 상태(state)를 나타내는 프로퍼티"와 "프로퍼티를 참조하고 조작할 수 있는 동작(behavior)인 메서드"를 "하나로 묶는 것."

정보 은닉(information hiding) : 캡슐화의 특징 중 하나로, "객체의 특정 프로퍼티나 메서드를 감출 목적으로 사용"


[왜 모듈 패턴을 사용하는 것인가?]

대부분의 객체지향 프로그래밍 언어는 접근 제한자(public, private, protected)를 사용해 공개 범위를 한정할 수 있다.
그러나, '자바스크립트는 접근 제한자를 제공하지 않는다.'

따라서, 모듈 패턴은 한정적인 기능이긴 하지만 정보 은닉을 구현하기 위해 사용하는 것이다.
```
<br>

```js

var Counter = (function () {
  // private 변수
  var num = 0;

  // 외부로 공개할 데이터나 메서드를 프로퍼티로 추가한 객체를 반환한다.
  return {
    increase() {
      return ++num;
    };
    decrease() {
      return --num;
    };
  };
}());  // 즉시실행 함수를 마지막에서 호출 & 함수 리터럴로 동작

// private 변수는 외부로 노출되지 않는다.
console.log(Counter.num); // undefined

// 즉시 실행 함수는 객체를 반환한다.
console.log(Counter.increase()); // 1
console.log(Counter.increase()); // 2
console.log(Counter.decrease()); // 1
console.log(Counter.decrease()); // 0

```

- 반환되는 객체의 프로퍼티는 외부에 노출되는 **퍼블릭 멤버(public member)** 다.

+ 외부로 노출하고 싶지 않는 변수나 함수는 반환하는 객체에 추가하지 않으면
외부에서 접근할 수 없는 **프라이빗 멤버(private member)** 가 된다.
<br>

## 4️⃣ ES6 모듈

> ES6 모듈은 `파일 자체의 독자적인 모듈 스코프를 제공`한다.
>> 그러나 ES6 모듈을 사용하면 `더는 전역 변수를 사용할 수 없다.`
<br>

```js

<script type="module" src="lib.mjs"></script>
<script type="module" src="app.mjs"></script>

```

- script 태그에 **type="module" 어트리뷰트를 추가**하면 모듈로서 동작한다.
  - **모듈의 파일 확장자는 mjs**를 권장한다.
